<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20 - 性能监控 | Three.js基础</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background-color: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .control-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            width: 250px;
            z-index: 100;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .control-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .sub-controls {
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid #555;
            margin-bottom: 10px;
        }

        button {
            background: #4285f4;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px 0;
            font-size: 12px;
            width: 100%;
        }

        button:hover {
            background: #3b78e7;
        }

        button.active {
            background: #ea4335;
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .slider-container label {
            flex: 1;
            margin-bottom: 0;
        }

        .slider-container input {
            flex: 2;
        }

        .slider-value {
            width: 40px;
            text-align: right;
            margin-left: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 3px;
            margin-bottom: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }

        .performance-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            max-width: 500px;
            font-size: 14px;
            line-height: 1.5;
            z-index: 100;
        }

        .performance-info h3 {
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .performance-info p {
            margin-bottom: 10px;
        }

        .performance-info ul {
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .technique-info {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(66, 133, 244, 0.2);
            border-radius: 3px;
        }

        .technique-info.active {
            display: block;
        }

        #stats-container {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 100;
        }

        #memory-stats-container {
            position: absolute;
            top: 50px;
            left: 0;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">20 - 性能监控 | Three.js基础教程</div>
    <div id="stats-container"></div>
    <div id="memory-stats-container"></div>
    
    <div class="control-panel">
        <h3>性能监控与优化控制面板</h3>

        <div class="control-group">
            <label>性能监控显示</label>
            <div class="sub-controls">
                <button id="toggle-stats">显示/隐藏FPS监控</button>
                <button id="toggle-memory-stats">显示/隐藏内存监控</button>
            </div>
        </div>

        <div class="control-group">
            <label>场景复杂度</label>
            <div class="sub-controls">
                <div class="slider-container">
                    <label for="object-count">对象数量:</label>
                    <input type="range" id="object-count" min="10" max="5000" value="100" step="10">
                    <span id="object-count-value" class="slider-value">100</span>
                </div>
                <div class="slider-container">
                    <label for="polygon-detail">几何体细节:</label>
                    <input type="range" id="polygon-detail" min="4" max="64" value="16" step="2">
                    <span id="polygon-detail-value" class="slider-value">16</span>
                </div>
                <button id="regenerate-scene">重新生成场景</button>
            </div>
        </div>

        <div class="control-group">
            <label>渲染优化</label>
            <div class="sub-controls">
                <div class="slider-container">
                    <label for="pixel-ratio">像素比:</label>
                    <input type="range" id="pixel-ratio" min="0.5" max="2" value="1" step="0.1">
                    <span id="pixel-ratio-value" class="slider-value">1</span>
                </div>
                <button id="toggle-antialias">开关抗锯齿</button>
                <button id="toggle-shadows">开关阴影</button>
                <button id="toggle-msaa">开关MSAA</button>
            </div>
        </div>

        <div class="control-group">
            <label>性能优化技术</label>
            <div class="sub-controls">
                <button id="toggle-instancing" class="technique-btn" data-technique="instancing">实例化渲染</button>
                <button id="toggle-lod" class="technique-btn" data-technique="lod">LOD (多细节层次)</button>
                <button id="toggle-frustum-culling" class="technique-btn" data-technique="frustum">视锥体剔除</button>
                <button id="toggle-object-pooling" class="technique-btn" data-technique="pooling">对象池</button>
                <button id="toggle-merge-geometries" class="technique-btn" data-technique="merge">合并几何体</button>
            </div>
        </div>

        <div class="control-group">
            <label>测试性能压力</label>
            <div class="sub-controls">
                <button id="add-lights">添加灯光 (+10)</button>
                <button id="add-physics">添加物理效果</button>
                <button id="add-postprocessing">添加后处理效果</button>
                <button id="reset-scene">重置场景</button>
            </div>
        </div>
    </div>

    <div class="performance-info">
        <h3>性能监控与优化介绍</h3>
        <p>Three.js应用的性能监控与优化对于创建流畅的3D体验至关重要，特别是在复杂场景或低性能设备上。</p>
        
        <p><strong>主要性能指标：</strong></p>
        <ul>
            <li><strong>FPS (每秒帧数)</strong>: 理想值为60帧以上，低于30帧会感觉卡顿</li>
            <li><strong>绘制调用 (Draw calls)</strong>: 每帧向GPU发送的渲染指令数量</li>
            <li><strong>三角形/顶点数</strong>: 场景中的几何复杂度</li>
            <li><strong>内存使用</strong>: JavaScript和GPU内存消耗</li>
        </ul>

        <p><strong>常用优化技术：</strong></p>
        <ul>
            <li><strong>实例化渲染</strong>: 使用相同几何体绘制多个对象</li>
            <li><strong>LOD (多细节层次)</strong>: 根据距离使用不同精度模型</li>
            <li><strong>对象合并</strong>: 合并静态对象减少绘制调用</li>
            <li><strong>视锥体剔除</strong>: 只渲染摄像机可见的对象</li>
            <li><strong>对象池</strong>: 重用对象而非创建销毁</li>
            <li><strong>着色器优化</strong>: 简化材质和光照计算</li>
        </ul>

        <div id="instancing-info" class="technique-info">
            <h4>实例化渲染</h4>
            <p>实例化渲染允许使用单个绘制调用渲染多个相同几何体的对象，大幅减少CPU开销。适用于粒子、树木、草等重复元素。</p>
        </div>

        <div id="lod-info" class="technique-info">
            <h4>LOD (多细节层次)</h4>
            <p>根据对象与摄像机的距离自动切换不同精度的几何体。远处使用低多边形模型，近处使用高精度模型，平衡视觉质量和性能。</p>
        </div>

        <div id="frustum-info" class="technique-info">
            <h4>视锥体剔除</h4>
            <p>自动或手动检测对象是否在摄像机视野内，不渲染视野外的对象。Three.js内置基础视锥体剔除，但复杂场景需要优化。</p>
        </div>

        <div id="pooling-info" class="technique-info">
            <h4>对象池</h4>
            <p>创建和销毁对象会导致内存碎片和垃圾回收暂停。对象池预先分配一组对象并重复使用它们，避免频繁创建销毁带来的性能损失。</p>
        </div>

        <div id="merge-info" class="technique-info">
            <h4>合并几何体</h4>
            <p>将多个静态几何体合并为一个大型几何体，减少绘制调用。适用于不需要单独移动或更新的对象，如环境、建筑等。</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { InstancedMesh } from 'three';
        import { LOD } from 'three';
        import Stats from 'https://unpkg.com/three@0.159.0/examples/jsm/libs/stats.module.js';

        // 创建性能监视器
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb
        document.getElementById('stats-container').appendChild(stats.dom);

        const memoryStats = new Stats();
        memoryStats.showPanel(2); // 显示内存面板
        document.getElementById('memory-stats-container').appendChild(memoryStats.dom);
        memoryStats.dom.style.display = 'none';

        // 初始化场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // 自定义性能指标对象
        const performanceMetrics = {
            drawCalls: 0,
            triangles: 0,
            points: 0,
            lines: 0,
            textures: 0,
            geometries: 0,
            materials: 0,
            objects: 0,
            lights: 0
        };

        // 性能配置对象
        const config = {
            objectCount: 100,
            polygonDetail: 16,
            pixelRatio: 1,
            antialias: true,
            shadows: false,
            msaa: false,
            techniques: {
                instancing: false,
                lod: false,
                frustumCulling: true, // 默认开启
                objectPooling: false,
                mergeGeometries: false
            },
            activeLights: 2,
            physicsEnabled: false,
            postprocessingEnabled: false,
            // 辅助状态变量
            objectsCreated: false,
            shouldRegenerate: false
        };

        // 维护对象引用以便于管理
        const sceneObjects = {
            meshes: [],
            lights: [],
            instances: null,
            lodObjects: [],
            mergedObject: null,
            objectPool: [],
            postprocessing: null
        };

        // 初始化相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 20);

        // 声明渲染器变量
        let renderer;
        
        // 创建渲染器函数 - 允许在更改抗锯齿等设置时重新创建
        function createRenderer() {
            // 如果已存在渲染器，从DOM中移除
            if (renderer && renderer.domElement && renderer.domElement.parentElement) {
                renderer.domElement.parentElement.removeChild(renderer.domElement);
            }

            // 创建新渲染器
            const newRenderer = new THREE.WebGLRenderer({
                antialias: config.antialias,
                powerPreference: 'high-performance'
            });
            
            newRenderer.setSize(window.innerWidth, window.innerHeight);
            newRenderer.setPixelRatio(Math.min(window.devicePixelRatio, config.pixelRatio));
            newRenderer.shadowMap.enabled = config.shadows;
            newRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            newRenderer.info.autoReset = false; // 不自动重置渲染器信息，我们需要在每帧获取它

            return newRenderer;
        }

        // 初始化渲染器
        renderer = createRenderer();
        document.body.appendChild(renderer.domElement);

        // 创建效果合成器 (用于后处理)
        let composer = null;
        
        function setupPostprocessing() {
            composer = new EffectComposer(renderer);
            
            // 添加基本渲染通道
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // 添加Bloom发光效果
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.5,  // 强度
                0.4,  // 半径
                0.85  // 阈值
            );
            composer.addPass(bloomPass);
            
            // 添加FXAA抗锯齿
            const fxaaPass = new ShaderPass(FXAAShader);
            const pixelRatio = renderer.getPixelRatio();
            fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * pixelRatio);
            fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * pixelRatio);
            composer.addPass(fxaaPass);
            
            return {
                composer,
                passes: {
                    render: renderPass,
                    bloom: bloomPass,
                    fxaa: fxaaPass
                }
            };
        }

        // 轨道控制器
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 添加基础光源
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        sceneObjects.lights.push(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        // 设置阴影相机参数以优化阴影质量和性能
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -15;
        directionalLight.shadow.camera.right = 15;
        directionalLight.shadow.camera.top = 15;
        directionalLight.shadow.camera.bottom = -15;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);
        sceneObjects.lights.push(directionalLight);

        // 创建地面
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555,
            side: THREE.DoubleSide,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // 基础性能显示指标初始化
        initBasePerformanceDisplay();
        function initBasePerformanceDisplay() {
            // 显示网格线，以便于观察场景
            const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
            scene.add(gridHelper);

            // 添加坐标轴辅助
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
        }

        // 生成随机颜色
        function getRandomColor() {
            return new THREE.Color(Math.random(), Math.random(), Math.random());
        }

        // 创建基础场景对象
        function createSceneObjects() {
            // 清除现有对象
            sceneObjects.meshes.forEach(mesh => scene.remove(mesh));
            sceneObjects.meshes = [];
            
            if (sceneObjects.instances) {
                scene.remove(sceneObjects.instances);
                sceneObjects.instances = null;
            }
            
            if (sceneObjects.mergedObject) {
                scene.remove(sceneObjects.mergedObject);
                sceneObjects.mergedObject = null;
            }
            
            sceneObjects.lodObjects.forEach(lod => scene.remove(lod));
            sceneObjects.lodObjects = [];

            // 创建基础几何体和材质
            const geometryOptions = [
                new THREE.BoxGeometry(1, 1, 1, config.polygonDetail / 4, config.polygonDetail / 4, config.polygonDetail / 4),
                new THREE.SphereGeometry(0.5, config.polygonDetail, config.polygonDetail),
                new THREE.ConeGeometry(0.5, 1, config.polygonDetail),
                new THREE.TorusGeometry(0.5, 0.2, config.polygonDetail / 2, config.polygonDetail),
                new THREE.TetrahedronGeometry(0.5, Math.floor(config.polygonDetail / 8))
            ];

            // 根据所选技术创建对象
            if (config.techniques.instancing) {
                // 使用实例化渲染
                createInstancedObjects(geometryOptions);
            } else if (config.techniques.lod) {
                // 使用LOD (Level of Detail)
                createLODObjects();
            } else if (config.techniques.mergeGeometries) {
                // 使用几何体合并
                createMergedGeometries(geometryOptions);
            } else {
                // 创建常规对象
                createRegularObjects(geometryOptions);
            }

            config.objectsCreated = true;
        }

        // 创建常规对象
        function createRegularObjects(geometryOptions) {
            const range = Math.ceil(Math.sqrt(config.objectCount)) * 2;
            
            for (let i = 0; i < config.objectCount; i++) {
                const geometry = geometryOptions[i % geometryOptions.length];
                const material = new THREE.MeshStandardMaterial({
                    color: getRandomColor(),
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // 设置随机位置
                mesh.position.set(
                    (Math.random() - 0.5) * range,
                    Math.random() * 5 + 0.5,
                    (Math.random() - 0.5) * range
                );
                
                // 设置随机旋转
                mesh.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                // 设置随机缩放
                const scale = Math.random() * 0.5 + 0.5;
                mesh.scale.set(scale, scale, scale);
                
                // 开启阴影
                mesh.castShadow = config.shadows;
                mesh.receiveShadow = config.shadows;
                
                // 设置视锥体剔除
                mesh.frustumCulled = config.techniques.frustumCulling;
                
                scene.add(mesh);
                sceneObjects.meshes.push(mesh);
            }
        }

        // 使用实例化渲染创建对象
        function createInstancedObjects(geometryOptions) {
            // 随机选择一个几何体
            const geometry = geometryOptions[Math.floor(Math.random() * geometryOptions.length)];
            const material = new THREE.MeshStandardMaterial({
                roughness: 0.7,
                metalness: 0.3
            });
            
            // 创建实例化网格
            const instancedMesh = new THREE.InstancedMesh(geometry, material, config.objectCount);
            instancedMesh.castShadow = config.shadows;
            instancedMesh.receiveShadow = config.shadows;
            instancedMesh.frustumCulled = config.techniques.frustumCulling;
            
            // 设置每个实例的变换矩阵和颜色
            const range = Math.ceil(Math.sqrt(config.objectCount)) * 2;
            const matrix = new THREE.Matrix4();
            
            for (let i = 0; i < config.objectCount; i++) {
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * range,
                    Math.random() * 5 + 0.5,
                    (Math.random() - 0.5) * range
                );
                
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                const scale = Math.random() * 0.5 + 0.5;
                
                matrix.compose(
                    position,
                    new THREE.Quaternion().setFromEuler(rotation),
                    new THREE.Vector3(scale, scale, scale)
                );
                
                instancedMesh.setMatrixAt(i, matrix);
                instancedMesh.setColorAt(i, getRandomColor());
            }
            
            // 更新实例化缓冲区
            instancedMesh.instanceMatrix.needsUpdate = true;
            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
            
            scene.add(instancedMesh);
            sceneObjects.instances = instancedMesh;
        }

        // 创建LOD (Level of Detail)对象
        function createLODObjects() {
            const range = Math.ceil(Math.sqrt(config.objectCount)) * 2;
            
            for (let i = 0; i < config.objectCount; i++) {
                // 创建3个不同细节级别的几何体
                const highDetailGeo = new THREE.SphereGeometry(0.5, config.polygonDetail, config.polygonDetail);
                const medDetailGeo = new THREE.SphereGeometry(0.5, Math.floor(config.polygonDetail / 2), Math.floor(config.polygonDetail / 2));
                const lowDetailGeo = new THREE.SphereGeometry(0.5, Math.floor(config.polygonDetail / 4), Math.floor(config.polygonDetail / 4));
                
                const material = new THREE.MeshStandardMaterial({
                    color: getRandomColor(),
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                // 创建LOD对象
                const lod = new THREE.LOD();
                
                // 添加不同细节级别
                lod.addLevel(new THREE.Mesh(highDetailGeo, material), 0);    // 近距离
                lod.addLevel(new THREE.Mesh(medDetailGeo, material), 5);     // 中距离
                lod.addLevel(new THREE.Mesh(lowDetailGeo, material), 15);    // 远距离
                
                // 设置位置
                lod.position.set(
                    (Math.random() - 0.5) * range,
                    Math.random() * 5 + 0.5,
                    (Math.random() - 0.5) * range
                );
                
                // 为每个LOD级别设置阴影
                lod.children.forEach(mesh => {
                    mesh.castShadow = config.shadows;
                    mesh.receiveShadow = config.shadows;
                });
                
                scene.add(lod);
                sceneObjects.lodObjects.push(lod);
            }
        }

        // 创建合并几何体
        function createMergedGeometries(geometryOptions) {
            // 创建BufferGeometryUtils如果需要
            const BufferGeometryUtils = {
                mergeBufferGeometries: function(geometries) {
                    let attributes = {};
                    let mergedGeometry = new THREE.BufferGeometry();
                    let offset = 0;
                    
                    for (let i = 0; i < geometries.length; i++) {
                        let geometry = geometries[i];
                        let positionAttribute = geometry.attributes.position;
                        
                        if (i === 0) {
                            // 第一个几何体，初始化属性
                            for (let key in geometry.attributes) {
                                if (geometry.attributes[key].isBufferAttribute) {
                                    attributes[key] = [];
                                }
                            }
                            
                            if (geometry.index !== null) {
                                mergedGeometry.setIndex([]);
                            }
                        }
                        
                        // 合并顶点属性
                        for (let key in geometry.attributes) {
                            if (geometry.attributes[key].isBufferAttribute) {
                                attributes[key].push(geometry.attributes[key].array);
                            }
                        }
                        
                        // 合并索引
                        if (geometry.index !== null) {
                            let indices = geometry.index.array;
                            for (let j = 0; j < indices.length; j++) {
                                mergedGeometry.index.push(indices[j] + offset);
                            }
                        }
                        
                        offset += positionAttribute.count;
                    }
                    
                    // 设置合并后的属性
                    for (let key in attributes) {
                        let mergedAttribute = new THREE.Float32BufferAttribute(
                            concatArrays(attributes[key]),
                            geometries[0].attributes[key].itemSize
                        );
                        mergedGeometry.setAttribute(key, mergedAttribute);
                    }
                    
                    return mergedGeometry;
                }
            };
            
            // 辅助函数，连接多个类型化数组
            function concatArrays(arrays) {
                let totalLength = 0;
                for (let arr of arrays) {
                    totalLength += arr.length;
                }
                
                let result = new Float32Array(totalLength);
                let offset = 0;
                
                for (let arr of arrays) {
                    result.set(arr, offset);
                    offset += arr.length;
                }
                
                return result;
            }
            
            // 创建多个几何体并应用变换
            const geometries = [];
            const range = Math.ceil(Math.sqrt(config.objectCount)) * 2;
            const matrix = new THREE.Matrix4();
            
            for (let i = 0; i < config.objectCount; i++) {
                const geometry = geometryOptions[i % geometryOptions.length].clone();
                
                // 应用随机变换
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * range,
                    Math.random() * 5 + 0.5,
                    (Math.random() - 0.5) * range
                );
                
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                const scale = Math.random() * 0.5 + 0.5;
                
                matrix.compose(
                    position,
                    new THREE.Quaternion().setFromEuler(rotation),
                    new THREE.Vector3(scale, scale, scale)
                );
                
                geometry.applyMatrix4(matrix);
                geometries.push(geometry);
            }
            
            // 合并所有几何体
            const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
            
            // 创建合并后的网格
            const material = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.7,
                metalness: 0.3,
                vertexColors: true
            });
            
            const mergedMesh = new THREE.Mesh(mergedGeometry, material);
            mergedMesh.castShadow = config.shadows;
            mergedMesh.receiveShadow = config.shadows;
            mergedMesh.frustumCulled = config.techniques.frustumCulling;
            
            scene.add(mergedMesh);
            sceneObjects.mergedObject = mergedMesh;
        }

        // 对象池管理
        function initObjectPool(size) {
            // 清空现有对象池
            sceneObjects.objectPool.forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
            });
            sceneObjects.objectPool = [];
            
            // 创建新对象池
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff5555,
                emissive: 0x331111,
                roughness: 0.4,
                metalness: 0.6
            });
            
            for (let i = 0; i < size; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.visible = false; // 初始不可见
                mesh.castShadow = config.shadows;
                mesh.receiveShadow = config.shadows;
                mesh.userData.inUse = false;
                mesh.userData.velocity = new THREE.Vector3();
                scene.add(mesh);
                sceneObjects.objectPool.push(mesh);
            }
        }

        // 从对象池获取对象
        function getFromPool() {
            for (let obj of sceneObjects.objectPool) {
                if (!obj.userData.inUse) {
                    obj.userData.inUse = true;
                    obj.visible = true;
                    return obj;
                }
            }
            return null; // 池已满
        }

        // 将对象返回池中
        function returnToPool(obj) {
            obj.userData.inUse = false;
            obj.visible = false;
        }

        // 添加随机光源
        function addRandomLights(count = 10) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            
            for (let i = 0; i < count; i++) {
                const light = new THREE.PointLight(
                    colors[Math.floor(Math.random() * colors.length)],
                    0.5,
                    10
                );
                
                light.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 5 + 1,
                    (Math.random() - 0.5) * 20
                );
                
                light.castShadow = config.shadows;
                
                // 创建可视化辅助
                const helper = new THREE.PointLightHelper(light, 0.5);
                scene.add(helper);
                scene.add(light);
                
                sceneObjects.lights.push(light);
            }
            
            config.activeLights += count;
        }

        // 添加基本物理效果模拟
        function setupPhysics() {
            // 这里我们模拟一个简单的重力和碰撞系统
            // 初始化对象池用于物理对象
            if (sceneObjects.objectPool.length === 0) {
                initObjectPool(100);
            }
            
            // 每隔一定时间生成新的物理对象
            setInterval(() => {
                if (!config.physicsEnabled) return;
                
                const obj = getFromPool();
                if (!obj) return;
                
                // 随机位置在天空中
                obj.position.set(
                    (Math.random() - 0.5) * 20,
                    15 + Math.random() * 5,
                    (Math.random() - 0.5) * 20
                );
                
                // 随机初始速度
                obj.userData.velocity.set(
                    (Math.random() - 0.5) * 0.2,
                    0,
                    (Math.random() - 0.5) * 0.2
                );
                
                // 5秒后回收
                setTimeout(() => {
                    returnToPool(obj);
                }, 5000);
                
            }, 100);
            
            config.physicsEnabled = true;
        }

        // 更新物理模拟
        function updatePhysics() {
            if (!config.physicsEnabled) return;
            
            const gravity = 0.01;
            const friction = 0.99;
            const restitution = 0.8; // 弹性
            
            sceneObjects.objectPool.forEach(obj => {
                if (!obj.userData.inUse) return;
                
                // 应用重力
                obj.userData.velocity.y -= gravity;
                
                // 更新位置
                obj.position.add(obj.userData.velocity);
                
                // 地面碰撞检测
                if (obj.position.y < 0.3) {
                    obj.position.y = 0.3;
                    obj.userData.velocity.y = -obj.userData.velocity.y * restitution;
                    
                    // 应用摩擦力
                    obj.userData.velocity.x *= friction;
                    obj.userData.velocity.z *= friction;
                }
                
                // 简单的墙壁碰撞
                const bounds = 25;
                ['x', 'z'].forEach(axis => {
                    if (Math.abs(obj.position[axis]) > bounds) {
                        obj.position[axis] = Math.sign(obj.position[axis]) * bounds;
                        obj.userData.velocity[axis] *= -restitution;
                    }
                });
            });
        }

        // 重置场景到基本状态
        function resetScene() {
            // 移除多余灯光
            while (sceneObjects.lights.length > 2) {
                const light = sceneObjects.lights.pop();
                scene.remove(light);
            }
            config.activeLights = 2;
            
            // 关闭物理模拟
            config.physicsEnabled = false;
            
            // 关闭后处理
            config.postprocessingEnabled = false;
            composer = null;
            
            // 重新生成场景对象
            config.shouldRegenerate = true;
        }

        // 更新统计信息
        function updatePerformanceMetrics() {
            // 从渲染器获取信息
            const info = renderer.info;
            
            performanceMetrics.drawCalls = info.render.calls;
            performanceMetrics.triangles = info.render.triangles;
            performanceMetrics.points = info.render.points;
            performanceMetrics.lines = info.render.lines;
            
            // 从内存获取信息
            performanceMetrics.textures = info.memory.textures;
            performanceMetrics.geometries = info.memory.geometries;
            
            // 从场景获取信息
            performanceMetrics.objects = 0;
            scene.traverse(object => {
                if (object.isMesh) performanceMetrics.objects++;
            });
            
            // 重置渲染器信息
            renderer.info.reset();
        }

        // UI控制
        setupControls();
        function setupControls() {
            // FPS监控切换
            document.getElementById('toggle-stats').addEventListener('click', () => {
                stats.dom.style.display = stats.dom.style.display === 'none' ? 'block' : 'none';
            });
            
            // 内存监控切换
            document.getElementById('toggle-memory-stats').addEventListener('click', () => {
                memoryStats.dom.style.display = memoryStats.dom.style.display === 'none' ? 'block' : 'none';
            });
            
            // 对象数量滑块
            const objectCountSlider = document.getElementById('object-count');
            const objectCountValue = document.getElementById('object-count-value');
            objectCountSlider.addEventListener('input', () => {
                config.objectCount = parseInt(objectCountSlider.value);
                objectCountValue.textContent = config.objectCount;
            });
            
            // 几何体细节滑块
            const polygonDetailSlider = document.getElementById('polygon-detail');
            const polygonDetailValue = document.getElementById('polygon-detail-value');
            polygonDetailSlider.addEventListener('input', () => {
                config.polygonDetail = parseInt(polygonDetailSlider.value);
                polygonDetailValue.textContent = config.polygonDetail;
            });
            
            // 重新生成场景按钮
            document.getElementById('regenerate-scene').addEventListener('click', () => {
                config.shouldRegenerate = true;
            });
            
            // 像素比滑块
            const pixelRatioSlider = document.getElementById('pixel-ratio');
            const pixelRatioValue = document.getElementById('pixel-ratio-value');
            pixelRatioSlider.addEventListener('input', () => {
                config.pixelRatio = parseFloat(pixelRatioSlider.value);
                pixelRatioValue.textContent = config.pixelRatio.toFixed(1);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, config.pixelRatio));
                
                // 如果有后处理，更新后处理的分辨率
                if (composer) {
                    composer.setPixelRatio(Math.min(window.devicePixelRatio, config.pixelRatio));
                    
                    // 更新FXAA抗锯齿通道的分辨率
                    const fxaaPass = composer.passes.find(pass => pass.material && pass.material.uniforms.resolution);
                    if (fxaaPass) {
                        fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * config.pixelRatio);
                        fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * config.pixelRatio);
                    }
                }
            });
            
            // 抗锯齿切换
            document.getElementById('toggle-antialias').addEventListener('click', () => {
                config.antialias = !config.antialias;
                renderer = createRenderer();
                document.body.appendChild(renderer.domElement);
                
                // 重新设置轨道控制器
                controls.dispose();
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // 如果启用了后处理，重新设置
                if (config.postprocessingEnabled) {
                    sceneObjects.postprocessing = setupPostprocessing();
                }
            });
            
            // 阴影切换
            document.getElementById('toggle-shadows').addEventListener('click', () => {
                config.shadows = !config.shadows;
                renderer.shadowMap.enabled = config.shadows;
                
                // 更新所有对象的阴影设置
                scene.traverse(object => {
                    if (object.isMesh) {
                        object.castShadow = config.shadows;
                        object.receiveShadow = config.shadows;
                    } else if (object.isLight && object.shadow) {
                        object.castShadow = config.shadows;
                    }
                });
            });
            
            // MSAA切换
            document.getElementById('toggle-msaa').addEventListener('click', () => {
                config.msaa = !config.msaa;
                
                if (config.msaa) {
                    renderer.setPixelRatio(1); // 降低像素比以提高性能
                    
                    // 创建MSAA渲染目标
                    const msaaRenderTarget = new THREE.WebGLRenderTarget(
                        window.innerWidth, 
                        window.innerHeight, 
                        {
                            samples: 4 // MSAA采样数
                        }
                    );
                    renderer.setRenderTarget(msaaRenderTarget);
                } else {
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, config.pixelRatio));
                    renderer.setRenderTarget(null);
                }
            });
            
            // 性能优化技术按钮
            document.querySelectorAll('.technique-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const technique = button.dataset.technique;
                    
                    // 重置所有技术
                    for (let key in config.techniques) {
                        config.techniques[key] = false;
                        document.querySelector(`[data-technique="${key}"]`).classList.remove('active');
                    }
                    
                    // 保留默认开启的视锥体剔除
                    config.techniques.frustumCulling = true;
                    
                    // 激活选中的技术
                    if (technique !== 'frustum') { // 不让用户关闭视锥体剔除
                        config.techniques[technique] = true;
                        button.classList.add('active');
                    }
                    
                    // 显示技术信息
                    document.querySelectorAll('.technique-info').forEach(info => {
                        info.classList.remove('active');
                    });
                    
                    const infoElement = document.getElementById(`${technique}-info`);
                    if (infoElement) {
                        infoElement.classList.add('active');
                    }
                    
                    // 对象池技术特殊处理
                    if (technique === 'pooling') {
                        initObjectPool(100);
                    }
                    
                    config.shouldRegenerate = true;
                });
            });
            
            // 添加灯光按钮
            document.getElementById('add-lights').addEventListener('click', () => {
                addRandomLights(10);
            });
            
            // 添加物理效果按钮
            document.getElementById('add-physics').addEventListener('click', () => {
                setupPhysics();
            });
            
            // 添加后处理效果按钮
            document.getElementById('add-postprocessing').addEventListener('click', () => {
                config.postprocessingEnabled = true;
                sceneObjects.postprocessing = setupPostprocessing();
            });
            
            // 重置场景按钮
            document.getElementById('reset-scene').addEventListener('click', () => {
                resetScene();
            });
        }

        // 响应窗口大小变化
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // 如果有后处理，更新后处理
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
                
                // 更新FXAA通道的分辨率
                const fxaaPass = composer.passes.find(pass => pass.material && pass.material.uniforms.resolution);
                if (fxaaPass) {
                    fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * config.pixelRatio);
                    fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * config.pixelRatio);
                }
            }
        });

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 开始性能测量
            stats.begin();
            memoryStats.begin();
            
            // 如果需要重新生成场景
            if (config.shouldRegenerate) {
                createSceneObjects();
                config.shouldRegenerate = false;
            }
            
            // 更新控制器
            controls.update();
            
            // 更新物理
            updatePhysics();
            
            // 更新LOD对象（在渲染前更新它们的可见性）
            if (config.techniques.lod) {
                THREE.LOD.updateVisibility(camera);
            }
            
            // 渲染场景
            if (config.postprocessingEnabled && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            
            // 更新性能指标
            updatePerformanceMetrics();
            
            // 结束性能测量
            stats.end();
            memoryStats.end();
        }
        
        // 启动动画循环
        animate();

        // 初始生成一些对象
        createSceneObjects();
    </script>
</body>
</html>
